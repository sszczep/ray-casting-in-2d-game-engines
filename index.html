<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">

    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous" async></script>

    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" async></script>
    <script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>

    <!-- Custom imports -->
    <link href="styles.css" rel="stylesheet">

    <!-- Demos -->
    <script src="assets/demos/demo1.js" async></script>
    <script src="assets/demos/demo2.js" async></script>
    <script src="assets/demos/demo3.js" async></script>
    <script src="assets/demos/demo4.js" async></script>

    <title>Ray casting in 2D game engines</title>
  </head>
  <body data-bs-spy="scroll" data-bs-target="#navbar" data-bs-offset="0" tabindex="0">
    <div class="container">
      <h1 class="text-center">Ray casting in 2D game engines</h1>
      <div class="row">
        <div class="col-md-3">
          <nav id="navbar" class="navbar flex-column align-items-stretch sticky-top">
            <nav class="nav nav-pills flex-column">
              <a class="nav-link" href="#introduction">Introduction</a>
              <nav class="nav nav-pills flex-column ms-3">
                <a class="nav-link" href="#the-purpose-of-this-article">The purpose of this article</a>
                <a class="nav-link" href="#what-is-ray-casting">What is ray casting?</a>
                <a class="nav-link" href="#where-ray-casting-might-be-used">Where ray casting might be used?</a>
                <nav class="nav nav-pills flex-column ms-3">
                  <a class="nav-link" href="#creating-3d-perspective-in-2d-map">Creating 3D perspective in a 2D map</a>
                  <a class="nav-link" href="#point-in-polygon-problem">Point-in-polygon problem</a>
                  <a class="nav-link" href="#object-visibility-and-light-casting">Object visibility and light casting</a>
                </nav> 
              </nav>
              <a class="nav-link" href="#ray-casting-in-top-view-2d-games">Ray casting in top view 2D games</a>
              <nav class="nav nav-pills flex-column ms-3">
                <a class="nav-link" href="#formulating-the-problem">Formulating the problem</a>
                <a class="nav-link" href="#calculating-line-segment-ray-intersection-point">Calculating line-segment - ray intersection point</a>
                <nav class="nav nav-pills flex-column ms-3">
                  <a class="nav-link" href="#deriving-line-parametric-equation">Deriving line parametric equation</a>
                  <a class="nav-link" href="#calculating-intersection-point">Calculating the intersection point</a>
                  <a class="nav-link" href="#finding-closest-intersection-point">Finding the closest intersection point</a>
                </nav>
                <a class="nav-link" href="#casting-rays">Casting rays</a>
                <nav class="nav nav-pills flex-column ms-3">
                  <a class="nav-link" href="#casting-rays-by-offset-angle">Casting rays by offset angle</a>
                  <a class="nav-link" href="#casting-rays-on-vertices">Casting rays on vertices</a>
                </nav>
              </nav>
            </nav>
          </nav>
        </div>
        <div class="col">
          <h2 id="introduction">Introduction</h2>

          <h3 id="the-purpose-of-this-article">The purpose of this article</h3>
          <p>
            In my opinion, ray casting is a very interesting concept that it is not that hard to grasp, but the quality resources are very limited. I want to thoroughly go over it so you can understand the math behind it and easily implement it in your future projects. I will try to make it as comprehensible as possible, explain all the caveats and issues you may stumble upon. We will also talk about optimization and how can spatial hashmaps significantly help you. I will also provide some basic live examples for you to try out. Please note that demos were written to be as simple as possible, do not expect enterprise grade code - we only learn about the concept, not the implementation.
          </p>

          <h3 id="what-is-ray-casting">What is ray casting?</h3>
          <figure>
            <blockquote class="blockquote">
              <p>
                Ray casting is the most basic of many computer graphics rendering algorithms that use the geometric algorithm of ray tracing. Ray tracing-based rendering algorithms operate in image order to render three-dimensional scenes to two-dimensional images...
                The idea behind ray casting is to <mark>trace rays from the eye, one per pixel, and find the closest object blocking the path of that ray</mark> – think of an image as a screen-door, with each square in the screen being a pixel. This is then the object the eye sees through that pixel.
              </p>
            </blockquote>
            <figcaption class="blockquote-footer">
              Wikipedia on <a href="https://en.wikipedia.org/wiki/Ray_casting">Ray casting</a>
            </figcaption>
          </figure>
          <p>
            Well, it does not tell us much, does it? Let me simplify that: Ray casting is a basic and popular technique used to determine the visibility of certain objects (for instance polygons) by tracing rays from the eye (eg. player’s character) on every pixel (well, not quite in our case - more on that later) and finding the nearest intersections with objects.
          </p>

          <h3 id="where-ray-casting-might-be-used">Where ray casting might be used?</h3>

          <h4 id="creating-3d-perspective-in-2d-map">Creating 3D perspective in a 2D map</h4>
          <p>
            The most well-known game that used this technique is Wolfenstein 3D. Rays were traced to determine the closest objects and their distance from the player position was used to appropriately scale them.
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <img src="assets/images/Simple_raycasting_with_fisheye_correction.gif" class="figure-img img-fluid" alt="Simple raycasting with fisheye correction">
            <figcaption class="figure-caption"><a href="https://commons.wikimedia.org/wiki/File:Simple_raycasting_with_fisheye_correction.gif">Simple raycasting with fisheye correction</a> by <a href="https://commons.wikimedia.org/wiki/User:LucasVB">Lucas Vieira</a></figcaption>
          </figure>

          <h4 id="point-in-polygon-problem">Point-in-polygon problem</h4>
          <p>
            PIP problem asks whether a given point lies inside, outside or on the boundary of a polygon. Using the Ray casting algorithm, we can count how many times the point intersects edges of the polygon. If the number of the intersections is even, the point is on the outside of the polygon. If the number of the intersections is odd, the point is on the inside or on the boundary of a polygon. 
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <img src="assets/images/pip.png" class="figure-img img-fluid" alt="Point-in-polygon problem using ray casting">
            <figcaption class="figure-caption">Point-in-polygon problem using ray casting</figcaption>
          </figure>

          <h4 id="object-visibility-and-light-casting">Object visibility and light casting</h4>
          <p>
            That is the problem we will specifically tackle in this article - determining which objects are visible by the player and illuminating the visible area. [screenshot of finished demo]
          </p>

          <h2 id="ray-casting-in-top-view-2d-games">Ray casting in top view 2D games</h3>

          <h3 id="formulating-the-problem">Formulating the problem</h3>
          <p>
            Given the set of line segments (eg. walls) find the visible area from a given point.
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <img src="assets/images/problem.png" class="figure-img img-fluid" alt="Ray casting in top view 2D games - the problem">
            <figcaption class="figure-caption">Ray casting in top view 2D games - the problem</figcaption>
          </figure>
          
          <h3 id="calculating-line-segment-ray-intersection-point">Calculating line-segment - ray intersection point</h3>

          <h4 id="deriving-line-parametric-equation">Deriving line parametric equation</h4>
          <p>
            Let us talk about lines and their parametric equation first. 
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <img src="assets/images/line.png" class="figure-img img-fluid" alt="Simple line example">
            <figcaption class="figure-caption">Simple line example</figcaption>
          </figure>
          <p>
            We can express vector \(\overrightarrow{AP}\) by the following equation: \(\overrightarrow{AP} = t\overrightarrow{AB}\), where \(t\) is an equation parameter defining how much do we stretch (\(|t| > 1\)) or shrink (\(|t| < 1\)) and if we flip the direction (\(t < 0\)) of vector \(\overrightarrow{AP}\) in relation to vector \(\overrightarrow{AB}\).
          </p>
          <p>
            Let me show you few examples:
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <img src="assets/images/line-t.png" class="figure-img img-fluid" alt="Line parametric equation parameter example">
            <figcaption class="figure-caption">Line parametric equation parameter example</figcaption>
          </figure>
          <p>
            As you might have noticed, we can use \(t\) as a scale factor: \(|AP| = |t||AB|\).
            We will use that fact when determining the closest intersection point. 
          </p>
          <p>
            Now we can easily see, that if we want the point to be contained on:
            <ul>
              <li>line: \(t \in \mathbb{R}\),</li>
              <li>ray: \(t \geq 0\),</li>
              <li>line-segment: \(0 \leq t \leq 1\).</li>
            </ul>
          </p>
          <p>
            Having all of that sorted out, we can finally derive the parametric equation:<br>
            \[
              \begin{align}
                \overrightarrow{AP} &= t \overrightarrow{AB} \\
                P - A &= t (B - A) \\
                P &= t(B - A) + A \\
              \end{align}
            \]
          </p>
          <p>
            If you still do not know what happens here, I can recommend an awesome short lecture by Norm Prokup: <a href="https://www.brightstorm.com/math/precalculus/vectors-and-parametric-equations/parametrizing-a-line-segment/">Parametrizing a Line Segment - Concept</a>.
          </p>

          <h4 id="calculating-intersection-point">Calculating the intersection point</h4>
          <p>
            Assume that point \(P\) is the intersection point of line-segment defined by points \(A\) and \(B\), and ray defined by points \(C\) and \(D\). Point \(P\) is then expressed by set of two equations:
            \[
              \left\{\begin{align}
                P &= s(B - A) + A\text {, where } 0 \leq s \leq 1 \text{, and} \\
                P &= r(D - C) + C\text {, where } r \geq 0 \text{.}
              \end{align}\right.
            \]
          </p>
          <p>
            Solve for \(s\) and \(r\):
            \[
              \left\{\begin{align}
                s(B_x - A_x) + A_x &= r(D_x - C_x) + C_x \Rightarrow s = \tfrac{r(D_x - C_x) + (C_x - A_x)}{B_x - A_x} \\
                s(B_y - A_y) + A_y &= r(D_y - C_y) + C_y \Rightarrow r = \tfrac{s(B_y - A_y) + (A_y - C_y)}{D_y - C_y}
              \end{align}\right.
            \]
          </p>
          <div class="row">
            <div class="col-xxl-6">
              <p class="text-center">
                substitute \(s\) into the second equation:
                \[
                  \begin{align}
                    &\tfrac{r(D_x - C_x) + (C_x - A_x)}{B_x - A_x} (B_y - A_y) + A_y = r(D_y - C_y) + C_y \\[10pt]
                    &r \tfrac{(D_x - C_x)(B_y - A_y)}{B_x - A_x} + \tfrac{(C_x - A_x)(B_y - A_y)}{B_x - A_x} + A_y = r(D_y - C_y) + C_y \\[10pt]
                    &r (\tfrac{(D_x - C_x)(B_y - A_y)}{B_x - A_x} - (D_y - C_y)) = (C_y - A_y) - \tfrac{(C_x - A_x)(B_y - A_y)}{B_x - A_x} \\[10pt]
                    &r \tfrac{(D_x - C_x)(B_y - A_y) - (D_y - C_y)(B_x - A_x)}{B_x - A_x} = \tfrac{(C_y - A_y)(B_x - A_x) - (C_x - A_x)(B_y - A_y)}{B_x - A_x} \\[10pt]
                    &r = \tfrac{(C_y - A_y)(B_x - A_x) - (C_x - A_x)(B_y - A_y)}{(D_x - C_x)(B_y - A_y) - (D_y - C_y)(B_x - A_x)} \\[10pt]
                    &r = \tfrac{(B_x - A_x)(C_y - A_y) - (C_x - A_x)(B_y - A_y)}{(D_x - C_x)(B_y - A_y) - (B_x - A_x)(D_y - C_y)} \\[10pt]
                  \end{align}
                \]
              </p>
            </div>
            <div class="col-xxl-6">
              <p class="text-center">
                substitute \(r\) into the first equation:
                \[
                  \begin{align}
                    &s(B_x - A_x) + A_x = \tfrac{s(B_y - A_y) + (A_y - C_y)}{D_y - C_y} (D_x - C_x) + C_x \\[10pt]
                    &s(B_x - A_x) + A_x = s \tfrac{(B_y - A_y)(D_x - C_x)}{D_y - C_y} + \tfrac{(A_y - C_y)(D_x - C_x)}{D_y - C_y} + C_x \\[10pt]
                    &s (\tfrac{(B_y - A_y)(D_x - C_x)}{D_y - C_y} - (B_x - A_x)) = (A_x - C_x) - \tfrac{(A_y - C_y)(D_x - C_x)}{D_y - C_y} \\[10pt]
                    &s \tfrac{(B_y - A_y)(D_x - C_x) - (B_x - A_x)(D_y - C_y)}{D_y - C_y} = \tfrac{(A_x - C_x)(D_y - C_y) - (A_y - C_y)(D_x - C_x)}{D_y - C_y} \\[10pt]
                    &s = \tfrac{(A_x - C_x)(D_y - C_y) - (A_y - C_y)(D_x - C_x)}{(B_y - A_y)(D_x - C_x) - (B_x - A_x)(D_y - C_y)} \\[10pt]
                    &s = \tfrac{(A_x - C_x)(D_y - C_y) - (D_x - C_x)(A_y - C_y)}{(D_x - C_x)(B_y - A_y) - (B_x - A_x)(D_y - C_y)} \\[10pt]
                  \end{align}
                \]
              </p>
            </div>
          </div>
          <p>
            Having \(s\) and \(r\) calculated, we can calculate \(P\) using one of the equations from the set.
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <canvas id="demo1" class="figure-img img-fluid"></canvas>
            <figcaption class="figure-caption">Demo 1 - all intersection points</figcaption>
          </figure>

          <h4 id="finding-closest-intersection-point">Finding the closest intersection point</h4>
          <p>
            We only need the closest intersection point to properly draw visible area. Naive solution would be to calculate distances between ray starting point and intersection points using <i>Pythagorean Theorem</i>: \(\sqrt{(C_x - P_x) ^ 2 + (C_y - P_y) ^ 2}\). Remember the line equation parameter though? I have already mentioned that we can use it as a scale factor. As we want to compare distances on ray, we can check for the smallest \(r\) parameter value.
            \[
              |\overrightarrow{CP_1}| < |\overrightarrow{CP_2}| \Leftrightarrow |r_1| < |r_2|
            \]
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <canvas id="demo2" class="figure-img img-fluid"></canvas>
            <figcaption class="figure-caption">Demo 2 - the closest intersection point</figcaption>
          </figure>

          <h3 id="casting-rays">Casting rays</h3>
          <p>
            In the following section we will go through two different ways rays might be cast. We will compare them and mention their pros and cons. 
          </p>

          <h4 id="casting-rays-by-offset-angle">Casting rays by offset angle</h4>
          <p>
            First way is to cast rays in all directions by specified offset angle. For instance, we could cast 30 rays in total offseted by \(12^\circ\). Let's see how to generate all those rays first.
          </p>
          <p>
            Let \(P_1 = (x_1, y_1)\) be an anchor point of our rays, and let \(P_2 = (x_2, y_2)\) be a some point on a line going through \(P_1\) at angle \(\phi\):
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <img src="assets/images/angle-offset.png" class="figure-img img-fluid" alt="Line from given point at some angle">
            <figcaption class="figure-caption">Line from given point at some angle</figcaption>
          </figure>
          <p>
            We can define \(x_2\) as \(x_1 + dx\) and \(y_2\) as \(y_1 - dy\) (our y-axis is inverted hence why the minus sign).<br>
            Now we need to derive formulas for \(dx\) and \(dy\):
            \[
              \begin{align}
                sin(\phi) &= \tfrac{dy}{\mathit{dist}} \Rightarrow dy = \mathit{dist} * sin(\phi) \\
                cos(\phi) &= \tfrac{dx}{\mathit{dist}} \Rightarrow dx = \mathit{dist} * cos(\phi)
              \end{align}
            \]
            \(\mathit{dist}\) in our case has an arbitrary value (we are looking for any point on the line), so we are safe to assume \(\mathit{dist} = 1\) to simplify the calculations. Having it all considered, \(P_2 = (x_1 + sin(\phi), y_1 - cos(\phi))\), where \(\phi\) is our angle offset. 
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <canvas id="demo3" class="figure-img img-fluid"></canvas>
            <figcaption class="figure-caption">Demo 3 - casting rays by offset angle</figcaption>
          </figure>

          <h4 id="casting-rays-on-vertices">Casting rays on vertices</h4>
          <p>
            Casting rays on vertices is most likely your go-to solution. Instead of casting rays in all directions, we can simply cast them on our polygons' vertices. Depending on the number of vertices, we can save computing power on not casting useless rays. Throughout next sections you will see how does it impact animation smoothness and also learn how to further optimize the whole process.
          </p>
          <figure class="figure my-3 mx-auto d-block text-center">
            <canvas id="demo4" class="figure-img img-fluid"></canvas>
            <figcaption class="figure-caption">Demo 4 - casting rays on vertices</figcaption>
          </figure>
        </div>
      </div>
    </div>
  </body>
</html>